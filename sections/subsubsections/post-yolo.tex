Although YOLO gives a pixel-precise mask for every panel, it still returns one mask when multiple balloons touch or overlap. Feeding a merged region to an OCR engine makes the text layout denser and usually causes a noticeable drop in recognition accuracy.

To address this, we introduce a post-processing step that leverages convexity defects to detect and split merged speech bubbles. The key observation is that when two bubbles are connected, the resulting contour often exhibits at least two deep concave regions — known as convexity defects. These defects serve as reliable cues for where a cut should be made.

Our algorithm proceeds as described in Algorithm \ref{alg:split-bubbles1} and \ref{alg:split-bubbles2}: for each mask returned by YOLO we extract the largest external contour, compute its convex hull and identify convexity defects—points where the contour deviates remarkably from its convex envelope—retaining only those that are both deep and angularly valid to suppress noise, then merge nearby defects to avoid over-segmentation; subsequently we draw a straight line between the closest pair of defects if at least two valid ones remain, whereas if only a single valid defect exists we skip the cut entirely since one defect alone does not furnish sufficient geometric evidence for a reliable split, and the entire process is applied recursively to each resulting sub-mask up to a predefined depth to handle more complex multi-bubble clusters.

The splitting procedure operates in two tightly-coupled functions. \texttt{SplitConnectedBubbles} serves as the recursive driver: it invokes \texttt{AttemptSplitOnce} on the input mask and, if more than one sub-mask is returned, recursively processes each fragment until the maximum recursion depth is reached. \texttt{AttemptSplitOnce} encapsulates the core geometric logic. It first extracts the largest contour and computes its convex hull. Using OpenCV's \texttt{convexityDefects}, it identifies points where the contour bends inward significantly. Each defect is characterized by four values: the start point $s$, end point $e$, farthest point $f$, and depth $d$. We retain only defects whose depth exceeds \texttt{MIN\_DEFECT\_DEPTH} (13 pixels) and whose interior angle---computed via the dot product of vectors $\vec{v_1} = s - f$ and $\vec{v_2} = e - f$---is less than \texttt{MAX\_ANGLE\_DEG} (170°). This angular constraint filters out shallow, wide concavities that are unlikely to represent merge boundaries.

After collecting candidates, we cluster them by sorting in descending order of depth and discarding any candidate within \texttt{MIN\_DIST} (20 pixels) of a previously retained one. If at least two unique defects remain, we select the closest pair from the top four deepest candidates and draw a black line between them, effectively severing the mask. Only when the cut produces multiple connected components with area greater than 100 pixels do we accept the split; otherwise, the original mask is returned unchanged. The recursion limit of 2 prevents excessive fragmentation while still handling typical two- or three-bubble clusters observed in manga panels.

\begin{table}[H]
\centering
\caption{Post-processing Parameters for Bubble Splitting}
\label{tab:bubble-split-params}
\begin{tabular}{lll}
\toprule
\textbf{Parameter} & \textbf{Value} & \textbf{Rationale} \\
\midrule
MIN\_DEFECT\_DEPTH & 13 px & Minimum depth of a defect to be considered \\
MAX\_ANGLE\_DEG & 170° & Maximum angle of a defect to be considered \\
MIN\_DIST & 20 px & Minimum distance between two defects to be considered \\
MIN\_AREA & 100 px$^2$ & Minimum area of a connected component to be considered \\
MAX\_RECURSION & 2 & Maximum recursion depth \\
\bottomrule
\end{tabular}
\end{table}

% --- Part 1: SplitConnectedBubbles ---
\begin{algorithm}[H]
\caption{Split Merged Speech Bubbles Using Convexity Defects (Part 1)}
\label{alg:split-bubbles1}
\begin{algorithmic}[1]
\State \textbf{Input:} $M$ (Binary mask of detected bubble), $depth$ (current recursion depth)
\State \textbf{Output:} List of separated bubble masks

\Function{SplitConnectedBubbles}{$M, depth$}
    \If{$depth \geq \text{MAX\_SPLIT\_DEPTH}$}
        \State \Return $[M]$
    \EndIf
    \State $sub\_masks \gets \Call{AttemptSplitOnce}{M}$

    \If{$|sub\_masks| = 1$}
        \State \Return $sub\_masks$
    \EndIf
    \State $result \gets \emptyset$
    \ForAll{$sub \in sub\_masks$}
        \State $result \gets result \cup \Call{SplitConnectedBubbles}{sub, depth + 1}$
    \EndFor
    \State \Return $result$
\EndFunction
\end{algorithmic}
\end{algorithm}
% --- Part 2: AttemptSplitOnce ---
\begin{algorithm}[H]
\caption{Split Merged Speech Bubbles Using Convexity Defects (Part 2)}
\label{alg:split-bubbles2}
\begin{algorithmic}[1]
\State \textbf{Input:} $M$ (Binary mask of detected bubble)
\State \textbf{Output:} List of separated bubble masks

\Function{AttemptSplitOnce}{$M$}
    \State $contour \gets \Call{LargestContour}{M}$
    \If{$contour = \emptyset$ \textbf{or} \Call{Area}{contour} < 500}
        \State \Return $[M]$
    \EndIf
    \State $hull \gets \Call{ConvexHull}{contour}$
    \State $defects \gets \Call{ConvexityDefects}{contour, hull}$
    \If{$defects = \emptyset$}
        \State \Return $[M]$
    \EndIf

    \State $candidates \gets \emptyset$
    \ForAll{$(s,e,f,d) \in defects$}
        \State $depth\_val \gets d / 256.0$
        \If{$depth\_val > \text{MIN\_DEFECT\_DEPTH}$}
            \State $\vec{v_1} \gets s - f$, $\vec{v_2} \gets e - f$
            \State $angle \gets \arccos\left(\frac{\vec{v_1} \cdot \vec{v_2}}{|\vec{v_1}| |\vec{v_2}|}\right)$
            \If{$angle < \text{MAX\_ANGLE\_DEG}$}
                \State $candidates \gets candidates \cup \{(f, depth\_val)\}$
            \EndIf
        \EndIf
    \EndFor

    \State $candidates \gets \Call{SortByDepth}{candidates, descending}$
    \State $unique \gets \emptyset$
    \ForAll{$c \in candidates$}
        \If{$\forall u \in unique: \|c.point - u.point\| \geq \text{MIN\_DIST}$}
            \State $unique \gets unique \cup \{c\}$
        \EndIf
    \EndFor

    \State $M_{cut} \gets M$
    \State $cut\_happened \gets false$
    \If{$|unique| \geq 2$}
        \State $top4 \gets$ first 4 elements of $unique$
        \State $(p_1,p_2) \gets \Call{ClosestPair}{top4}$
        \State \Call{DrawLine}{$M_{cut}, p_1, p_2$, color=0, thickness=3}
        \State $cut\_happened \gets true$
    \EndIf

    \If{$cut\_happened$}
        \State $contours_{new} \gets \Call{FindContours}{M_{cut}}$
        \State $masks_{new} \gets \emptyset$
        \ForAll{$c \in contours_{new}$}
            \If{\Call{Area}{c} > 100}
                \State $m \gets \Call{CreateMaskFrom}{c}$
                \State $masks_{new} \gets masks_{new} \cup \{m\}$
            \EndIf
        \EndFor
        \If{$|masks_{new}| > 1$}
            \State \Return $masks_{new}$
        \EndIf
    \EndIf

    \State \Return $[M]$
\EndFunction
\end{algorithmic}
\end{algorithm}
